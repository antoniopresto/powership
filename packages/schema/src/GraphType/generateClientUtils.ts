import * as path from 'path';

import * as fs from 'fs-extra';

import { ObjectType, parseFieldDefinitionConfig } from '../ObjectType';
import {
  GraphQLSchemaWithUtils,
  resolversTypescriptParts,
} from '../createGraphQLSchema';

import { getSchemaQueryExamples } from './getQueryExamples';

const clientBody = fs.readFileSync(
  path.join(__dirname, 'generateClient_body.txt'),
  'utf-8'
);

export async function generateClientUtils(schema: GraphQLSchemaWithUtils) {
  const {
    prettier: { format },
  } = ObjectType.serverUtils();

  const [tsParts, queryExamples] = await Promise.all([
    resolversTypescriptParts({
      name: 'GraphQLInterfaces',
      options: {},
      resolvers: schema.utils.resolvers,
    }),

    getSchemaQueryExamples(schema),
  ]);

  const header = [
    '// Autogenerated, do not edit by hand',
    '/* istanbul ignore file */',
    '/* eslint-disable */',
    //
    "import { GraphType } from '@darch/schema';\n\n",
    '\nexport type GraphQLClientError = { message: string, path: string[] };\n', //
    '\nexport type ID = number | string;\n', //
    `\nexport type GraphQLClientResponse<Result> = {data: Result, errors: null} | {data: null, errors: GraphQLClientError[]}\n`,
  ];

  let clientInterface = ``;

  clientInterface += `\nexport interface ExpectedGraphQLClient {\n`;

  let helpersText = `\n\n`;
  helpersText += `\nexport const graphqlClientHelpers = {\n`;

  const commonTypings = new Map<string, string>();

  // adding the input (args) and payload types for each resolver
  tsParts.lines.forEach(({ payloadName, args, payload, inputName }) => {
    commonTypings.set(
      payloadName,
      `export type ${payloadName} = ${payload.code}`
    );
    commonTypings.set(inputName, `export type ${inputName} = ${args.code}`);
  });

  // adding the GraphqlClient interface for each resolver
  tsParts.lines.forEach(
    ({
      payloadName,
      inputName,
      resolver: { description, deprecationReason, name, args: resolverArgs },
    }) => {
      clientInterface += description ? `/**\n${description}\n**/` : '';
      clientInterface += deprecationReason
        ? `/**\n@deprecated\n${deprecationReason}\n**/`
        : '';

      const argsText = resolverArgs
        ? `args: ${inputName}`
        : `args?: ${inputName}`;

      clientInterface += `\n${name}: {${argsText}, payload: GraphQLClientResponse<${payloadName}>},`;

      clientInterface += `\n`;
    }
  );

  // adding the query and fragment texts for each resolver
  tsParts.lines.forEach(
    ({
      payloadName,
      inputName,
      resolver: { name, typeDef, kind, argsDef },
    }) => {
      helpersText += `\n${name}: {\n name: "${name}", \n`;

      helpersText += `kind: '${kind}',payload: ${rehydrateType(
        payloadName,
        typeDef
      )},\n`;

      helpersText += `\ninput: ${rehydrateType(
        inputName,
        argsDef
          ? { object: argsDef }
          : { record: { keyType: 'string', type: 'unknown' } }
      )},\n`;

      const resolverQueries = queryExamples.queryByResolver[kind][name];

      helpersText += `\noperation: ${JSON.stringify(
        {
          varNames: resolverQueries.argsParsed.vars.reduce((acc, next) => {
            return {
              ...acc,
              [next.name]: {
                ...next,
                // example -> "limit": "cashbackIntervals_limit"
                varName: next.varName.replace(/^\$/, ''),
              },
            };
          }, {} as any),
          query: resolverQueries.fullQuery,
        },
        null,
        2
      )} as const,\n`;

      helpersText += `\n},\n`;
    }
  );

  clientInterface += `\n}\n`;
  helpersText += `\n} as const;\n`;
  helpersText += clientBody;

  const result = [
    header.join('\n\n'), //
    [...commonTypings.values()].join('\n\n'),
    clientInterface,
    helpersText,
  ].join('\n');

  return format(result, {
    parser: 'typescript',
    singleQuote: true,
  });
}

let creating = false;
export async function saveGraphQLClientUtils(
  schema: GraphQLSchemaWithUtils,
  DEST: string
) {
  if (creating) return;
  creating = true;

  const exists = fs.existsSync(DEST);
  const now = Date.now();
  const mtime = exists ? fs.statSync(DEST).mtimeMs : 0;

  const diff = now - mtime;
  if (diff < 3000) return;

  console.info(`saveGraphQLTypescript in progress.`);
  const ts = await generateClientUtils(schema);

  if (exists) {
    await fs.remove(DEST);
  }

  await fs.ensureFile(DEST);
  await fs.writeFile(DEST, ts);

  creating = false;
  console.info(`generated in ${DEST}`);
}

function rehydrateType(name: string, field: any) {
  const parsed = parseFieldDefinitionConfig(field);
  const json = JSON.stringify(parsed);
  return `GraphType.getOrSet("${name}", ${json} as const)`;
}
